# LeetCode 26: 删除有序数组中的重复项

## 📝 题目描述

给你一个**非严格递增排列**的数组 `nums`，请你**原地**删除重复出现的元素，使每个元素**只出现一次**，返回删除后数组的新长度。元素的**相对顺序**应该保持**一致**。

### 示例
```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]

输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
```

## 🎯 解题思路

### 核心思想：双指针法

这道题的关键是**改变思维方式**：
- ❌ 不要想"如何删除重复的元素"
- ✅ 而要想"如何保留不重复的元素"

### 双指针分工
- **慢指针 (slow)**：指向当前不重复元素应该放置的位置
- **快指针 (fast)**：遍历整个数组，寻找新的不重复元素

## 💻 代码实现

```rust
impl Solution {
    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {
        // 特殊情况：如果数组为空，直接返回0
        if nums.is_empty() {
            return 0;
        }
        
        // 双指针法：
        // slow: 慢指针，指向当前不重复元素应该放置的位置
        // fast: 快指针，遍历整个数组寻找不重复元素
        let mut slow = 0;
        
        // 从第二个元素开始遍历（因为第一个元素肯定是不重复的）
        for fast in 1..nums.len() {
            // 如果快指针指向的元素与慢指针指向的元素不同
            // 说明找到了一个新的不重复元素
            if nums[fast] != nums[slow] {
                // 慢指针向前移动一位
                slow += 1;
                // 将新的不重复元素放到慢指针的位置
                nums[slow] = nums[fast];
            }
            // 如果 nums[fast] == nums[slow]，说明是重复元素
            // 快指针继续向前，慢指针不动
        }
        
        // 返回不重复元素的个数（slow + 1，因为索引从0开始）
        (slow + 1) as i32
    }
}
```

## 🔍 算法步骤详解

以数组 `[1, 1, 2, 2, 3, 3, 4, 4, 5, 5]` 为例：

### 初始状态
```
数组: [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]
      ↑  ↑
    slow fast
```

### 遍历过程
```
fast=1: nums[1]=1, nums[0]=1, 相等 → slow不动，fast继续
fast=2: nums[2]=2, nums[0]=1, 不等 → slow移到1，nums[1]=2
fast=3: nums[3]=2, nums[1]=2, 相等 → slow不动，fast继续  
fast=4: nums[4]=3, nums[1]=2, 不等 → slow移到2，nums[2]=3
fast=5: nums[5]=3, nums[2]=3, 相等 → slow不动，fast继续
fast=6: nums[6]=4, nums[2]=3, 不等 → slow移到3，nums[3]=4
fast=7: nums[7]=4, nums[3]=4, 相等 → slow不动，fast继续
fast=8: nums[8]=5, nums[3]=4, 不等 → slow移到4，nums[4]=5
fast=9: nums[9]=5, nums[4]=5, 相等 → slow不动，fast继续
```

### 最终结果
```
数组变为: [1, 2, 3, 4, 5, 3, 4, 4, 5, 5]
前5个元素: [1, 2, 3, 4, 5] ← 这就是去重后的结果
返回: slow + 1 = 4 + 1 = 5
```

## 🚀 复杂度分析

- **时间复杂度：O(n)** - 只遍历一次数组
- **空间复杂度：O(1)** - 只使用了常数级别的额外空间

## 🧠 解题思维总结

### 为什么第一次想不到这种解法？

1. **思维定势**：容易陷入"如何删除重复元素"的复杂思路
2. **缺乏模式积累**：不熟悉双指针这种经典解题模式
3. **抽象层次**：没有从"删除重复"转换到"保留不重复"的思维

### 如何改进思考方式？

#### 1. 学会"换个角度"
- 遇到"删除X"类问题 → 想"如何保留非X"
- 遇到"移除X"类问题 → 想"如何重新构建"

#### 2. 掌握解题模式
**双指针模式**适用于：
- 数组去重
- 移除特定元素  
- 合并有序数组
- 反转数组

#### 3. 从具体到抽象的思考
```
具体例子 → 期望结果 → 实现方式 → 抽象模式
```

#### 4. 多问"为什么"
- 为什么要用双指针？→ 需要两个不同的位置信息
- 为什么慢指针不用每次都移动？→ 只有找到新元素时才需要"放置"
- 为什么从索引1开始？→ 第一个元素天然就是"不重复的"

## 🎯 双指针通用框架

```rust
// 双指针模式的通用框架
let mut slow = 0;
for fast in 1..nums.len() {
    if condition_met(nums[fast], nums[slow]) {
        slow += 1;
        nums[slow] = nums[fast];
    }
}
return slow + 1;
```

## 📚 相关题目推荐

练习同类型题目，形成**模式识别**能力：
- [LeetCode 27: 移除元素](https://leetcode.cn/problems/remove-element/)
- [LeetCode 80: 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)
- [LeetCode 283: 移动零](https://leetcode.cn/problems/move-zeroes/)

## 💡 学习心得

> **编程不是靠灵感，而是靠模式积累！**

1. **理解能力强**不等于**解题能力强**
2. 看懂别人的代码容易，自己想出解法需要**模式积累**
3. 遇到新题时：
   - 先想"我要得到什么结果"
   - 再想"用什么经典模式可以达到这个结果"
   - 最后思考"为什么这样想"

记住：每掌握一个解题模式，下次遇到类似问题就会更有感觉！

---

**运行方式：**
```bash
rust-script lc26.rs
``` 